<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ù…Ø±Ø¨ÛŒ ØªÙÚ©Ø± ØªØ¹Ø§ÙˆÙ† Ø¢ÙØ±ÛŒÙ†ÛŒ</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Vazirmatn", Arial, sans-serif;
      background: #fafafa; color: #333; height: 100vh; overflow: hidden;
    }
    #app { display: flex; flex-direction: column; height: 100vh; max-width: 1400px; margin: 0 auto; padding: 16px; gap: 12px; }
    
    /* Header */
    .header { display: flex; justify-content: space-between; align-items: center; padding: 10px 16px; background: #fff; border: 1px solid #e5e5e5; border-radius: 8px; }
    .header-title { font-size: 15px; font-weight: 600; }
    .header-actions { display: flex; gap: 8px; align-items: center; }
    .btn-icon { width: 32px; height: 32px; border: 1px solid #ddd; background: #fff; border-radius: 6px; cursor: pointer; display: grid; place-items: center; font-size: 16px; }
    .btn-icon:hover { background: #f5f5f5; }
    
    /* Input Section - Collapsed State */
    .input-collapsed-bar { display: none; padding: 8px 12px; background: #fff; border: 1px solid #e5e5e5; border-radius: 8px; font-size: 13px; color: #666; cursor: pointer; align-items: center; justify-content: space-between; }
    .input-collapsed-bar:hover { background: #f9f9f9; }
    .input-preview { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    body.input-hidden .input-collapsed-bar { display: flex; }
    body.input-hidden .sidebar .panel:first-child { display: none; }
    
    /* Layout */
    .layout { display: flex; gap: 12px; flex: 1; min-height: 0; }
    .sidebar { width: 340px; display: flex; flex-direction: column; gap: 12px; flex-shrink: 0; }
    .panel { background: #fff; border: 1px solid #e5e5e5; border-radius: 8px; padding: 12px; }
    .input-label { font-size: 12px; color: #666; margin-bottom: 8px; }
    #user-idea { width: 100%; min-height: 100px; max-height: 180px; resize: vertical; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; outline: none; }
    #user-idea:focus { border-color: #4a90e2; }
    .input-actions { margin-top: 8px; display: flex; gap: 8px; justify-content: flex-end; }
    .btn-primary { padding: 8px 14px; background: #4a90e2; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; }
    .btn-primary:hover { background: #357abd; }
    .btn-primary:disabled { background: #ccc; cursor: not-allowed; }
    
    /* Steps */
    .steps-title { font-size: 12px; color: #666; margin-bottom: 8px; }
    .steps-list { list-style: none; display: flex; flex-direction: column; gap: 6px; max-height: calc(50vh - 100px); overflow: auto; }
    .step-item { display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 6px; font-size: 13px; }
    .step-number { width: 22px; height: 22px; border-radius: 50%; background: #eee; display: grid; place-items: center; font-size: 11px; flex-shrink: 0; }
    .step-dot { width: 8px; height: 8px; border-radius: 50%; background: #ddd; }
    .step-item[data-status=running] .step-number { background: #4a90e2; color: #fff; }
    .step-item[data-status=running] .step-dot { background: #4a90e2; animation: pulse 1.5s infinite; }
    .step-item[data-status=running] .step-label::after {
      content: "...";
      display: inline-block;
      width: 20px;
      text-align: left;
      margin-right: 4px;
      animation: dots 1.4s steps(4, end) infinite;
    }
    .step-item[data-status=done] .step-number { background: #4caf50; color: #fff; }
    .step-item[data-status=done] .step-dot { background: #4caf50; }
    
    /* Content */
    .content { flex: 1; background: #fff; border: 1px solid #e5e5e5; border-radius: 8px; padding: 12px; overflow: auto; min-height: 0; }
    .placeholder { color: #999; font-size: 13px; text-align: center; padding: 40px 20px; }
    
    /* Operation Cards */
    .op-card { border: 1px solid #e5e5e5; border-radius: 8px; padding: 12px; margin-bottom: 12px; background: #fafafa; }
    .op-head { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .op-title { display: flex; align-items: center; gap: 8px; font-weight: 600; font-size: 14px; }
    .op-num { width: 20px; height: 20px; border-radius: 50%; background: #e5e5e5; display: grid; place-items: center; font-size: 11px; }
    .op-status { font-size: 12px; color: #666; }
    .op-body { display: flex; flex-direction: column; gap: 10px; }
    
    /* Thinking */
    .thinking { background: #f9f9f9; border: 1px solid #e5e5e5; border-radius: 6px; padding: 10px; }
    .thinking-label { display: flex; align-items: center; gap: 8px; font-size: 12px; color: #666; margin-bottom: 6px; }
    .dots {
      display: inline-block;
      width: 20px;
      text-align: left;
    }
    .dots::after {
      content: "...";
      animation: dots 1.4s steps(4, end) infinite;
    }
    @keyframes dots {
      0% { content: "."; }
      25% { content: ".."; }
      50% { content: "..."; }
      75%, 100% { content: "..."; }
    }
    .arrow { width: 20px; height: 20px; border: 1px solid #ddd; background: #fff; color: #555; display: grid; place-items: center; border-radius: 4px; cursor: pointer; font-size: 12px; }
    .arrow:hover { background: #f3f3f3; }
    .thinking.collapsed .thinking-text { display: none; }
    .thinking-text { font-family: ui-monospace, Menlo, Monaco, monospace; font-size: 11px; white-space: pre-wrap; line-height: 1.6; color: #666; }
    
    /* Result */
    .result-label { font-size: 12px; color: #666; margin-bottom: 6px; font-weight: 600; }
    .result-content { font-size: 14px; line-height: 1.7; }
    .result-content strong, .result-content b { font-weight: 600; }
    .result-content em, .result-content i { font-style: italic; }
    
    /* Error & Retry */
    .error { color: #b00020; background: #fdecee; border: 1px solid #f6c2c8; border-radius: 6px; padding: 10px; font-size: 12px; }
    .retry-btn { margin-top: 8px; padding: 6px 12px; background: #4a90e2; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; }
    .retry-btn:hover { background: #357abd; }
    
    /* Value Chain Diagram */
    .chain-diagram { display: flex; align-items: center; gap: 12px; margin-top: 12px; overflow-x: auto; padding: 20px 10px; }
    .chain-node { position: relative; display: flex; flex-direction: column; align-items: center; gap: 8px; min-width: 120px; }
    .chain-circle { width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, #4a90e2, #357abd); color: #fff; display: grid; place-items: center; font-weight: 600; cursor: pointer; transition: transform 0.2s; box-shadow: 0 2px 8px rgba(74,144,226,0.3); }
    .chain-circle:hover { transform: scale(1.1); }
    .chain-label { font-size: 11px; color: #666; text-align: center; max-width: 120px; }
    .chain-connector { width: 40px; height: 2px; background: #ddd; margin-bottom: 30px; }
    .chain-bubble { position: absolute; top: 60px; left: 50%; transform: translateX(-50%); background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 12px; min-width: 200px; max-width: 280px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); z-index: 10; font-size: 12px; line-height: 1.6; display: none; }
    .chain-bubble.active { display: block; }
    .chain-bubble::before { content: ''; position: absolute; top: -6px; left: 50%; transform: translateX(-50%); width: 12px; height: 12px; background: #fff; border: 1px solid #ddd; border-bottom: none; border-right: none; transform: translateX(-50%) rotate(45deg); }
    
    /* Canvas */
    .canvas { list-style: none; margin-top: 8px; }
    .canvas li { padding: 8px 0; border-bottom: 1px solid #f0f0f0; }
    .canvas li:last-child { border-bottom: 0; }
    .canvas .key { color: #4a90e2; font-weight: 600; }
    
    /* Infographic */
    .infographic { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-top: 12px; }
    .ig-card { border: 1px solid #cfe4ff; background: #f3f8ff; border-radius: 6px; padding: 12px; }
    .ig-title { font-weight: 600; margin-bottom: 4px; }
    .ig-cap { font-size: 12px; color: #666; margin-bottom: 8px; }
    
    /* Checklist Cards */
    .checklist { display: flex; flex-direction: column; gap: 10px; margin-top: 12px; }
    .task-card { background: #fff; border: 1px solid #e5e5e5; border-radius: 8px; padding: 12px; cursor: pointer; transition: all 0.2s; }
    .task-card:hover { border-color: #4a90e2; box-shadow: 0 2px 8px rgba(74,144,226,0.15); }
    .task-header { display: flex; align-items: center; gap: 10px; }
    .task-checkbox { width: 18px; height: 18px; cursor: pointer; }
    .task-title { flex: 1; font-size: 14px; font-weight: 500; }
    .task-title.completed { text-decoration: line-through; color: #999; }
    .task-meta { font-size: 11px; color: #999; margin-left: 10px; }
    .task-actions { display: flex; gap: 6px; }
    .task-btn { padding: 4px 10px; border: 1px solid #ddd; background: #fff; border-radius: 6px; font-size: 11px; cursor: pointer; }
    .task-btn:hover { background: #f5f5f5; }
    .task-details { margin-top: 12px; padding-top: 12px; border-top: 1px solid #f0f0f0; font-size: 13px; line-height: 1.6; color: #666; display: none; }
    .task-details.open { display: block; }
    
    /* Settings Modal */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1000; }
    .modal-overlay.active { display: flex; }
    .modal { background: #fff; border-radius: 12px; max-width: 800px; width: 90%; max-height: 85vh; overflow: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.2); }
    .modal-header { padding: 16px 20px; border-bottom: 1px solid #e5e5e5; display: flex; justify-content: space-between; align-items: center; }
    .modal-title { font-size: 16px; font-weight: 600; }
    .modal-close { width: 28px; height: 28px; border: none; background: #f5f5f5; border-radius: 6px; cursor: pointer; font-size: 18px; }
    .modal-close:hover { background: #e5e5e5; }
    .modal-body { padding: 20px; }
    .setting-group { margin-bottom: 24px; }
    .setting-label { font-size: 13px; font-weight: 600; margin-bottom: 8px; color: #333; }
    .setting-desc { font-size: 12px; color: #666; margin-bottom: 8px; }
    select, input[type=text] { width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 13px; }
    textarea.setting-textarea { width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 12px; font-family: monospace; }
    .btn-save { padding: 8px 16px; background: #4a90e2; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; }
    .btn-save:hover { background: #357abd; }
    
    /* API Keys Management */
    .api-keys-section { margin-top: 24px; }
    .api-key-card { background: #f9f9f9; border: 1px solid #e5e5e5; border-radius: 8px; padding: 12px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; gap: 12px; }
    .api-key-info { flex: 1; }
    .api-key-value { font-family: monospace; font-size: 11px; color: #666; margin-bottom: 6px; word-break: break-all; }
    .api-key-stats { display: flex; gap: 16px; font-size: 11px; }
    .stat-item { display: flex; flex-direction: column; gap: 2px; }
    .stat-label { color: #999; }
    .stat-value { font-weight: 600; }
    .stat-value.success { color: #4caf50; }
    .stat-value.error { color: #f44336; }
    .stat-value.active { color: #4a90e2; animation: pulse 1.5s infinite; }
    .api-key-actions { display: flex; gap: 6px; }
    .btn-small { padding: 4px 10px; border: 1px solid #ddd; background: #fff; border-radius: 6px; cursor: pointer; font-size: 11px; }
    .btn-small:hover { background: #f5f5f5; }
    .btn-small.danger { border-color: #f44336; color: #f44336; }
    .btn-small.danger:hover { background: #ffebee; }
    .btn-add-key { width: 100%; padding: 10px; border: 2px dashed #ddd; background: #fff; border-radius: 8px; cursor: pointer; font-size: 13px; color: #666; margin-top: 10px; }
    .btn-add-key:hover { border-color: #4a90e2; color: #4a90e2; }
    .add-key-input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 12px; font-family: monospace; margin-top: 8px; }
    
    /* Steps Cards Management */
    .steps-cards-container { display: flex; flex-direction: column; gap: 12px; margin-top: 12px; }
    .step-card { background: #fff; border: 2px solid #e5e5e5; border-radius: 10px; padding: 16px; position: relative; transition: all 0.2s; }
    .step-card:hover { border-color: #4a90e2; box-shadow: 0 2px 8px rgba(74, 144, 226, 0.1); }
    .step-card.editing { border-color: #4a90e2; box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1); }
    .step-card-header { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; }
    .step-card-number { width: 32px; height: 32px; border-radius: 8px; background: linear-gradient(135deg, #4a90e2, #357abd); color: #fff; display: grid; place-items: center; font-size: 14px; font-weight: 600; flex-shrink: 0; }
    .step-card-title { flex: 1; font-size: 15px; font-weight: 600; color: #333; }
    .step-card-actions { display: flex; gap: 6px; }
    .btn-card-action { width: 32px; height: 32px; border: 1px solid #ddd; background: #fff; border-radius: 6px; cursor: pointer; display: grid; place-items: center; font-size: 14px; transition: all 0.2s; }
    .btn-card-action:hover { background: #f5f5f5; border-color: #4a90e2; color: #4a90e2; }
    .btn-card-action.danger:hover { border-color: #f44336; color: #f44336; background: #ffebee; }
    .step-card-fields { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; }
    .step-card-field { display: flex; flex-direction: column; gap: 6px; }
    .step-card-field.full-width { grid-column: 1 / -1; }
    .step-card-field-label { font-size: 11px; color: #666; font-weight: 500; }
    .step-card-field-input { padding: 8px 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 13px; outline: none; transition: border-color 0.2s; }
    .step-card-field-input:focus { border-color: #4a90e2; }
    .step-card-field-input[readonly] { background: #f9f9f9; color: #999; cursor: not-allowed; }
    .step-card-view { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; }
    .step-card-view-item { display: flex; flex-direction: column; gap: 4px; }
    .step-card-view-label { font-size: 11px; color: #999; }
    .step-card-view-value { font-size: 13px; color: #333; }
    .btn-add-step { width: 100%; padding: 12px; border: 2px dashed #4a90e2; background: #f0f7ff; border-radius: 10px; cursor: pointer; font-size: 14px; color: #4a90e2; font-weight: 500; margin-top: 8px; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px; }
    .btn-add-step:hover { background: #e0efff; border-color: #357abd; }
    .step-card-drag-handle { cursor: move; color: #999; }
    .step-card-drag-handle:hover { color: #4a90e2; }
    .btn-card-action:disabled { opacity: 0.4; cursor: not-allowed; }
    .btn-card-action:disabled:hover { background: #fff; border-color: #ddd; color: inherit; }
    @media (max-width: 768px) {
      .step-card-fields, .step-card-view { grid-template-columns: 1fr; }
      .step-card-header { flex-wrap: wrap; }
      .step-card-actions { width: 100%; justify-content: flex-end; margin-top: 8px; }
    }
    
    /* Tabs */
    .tabs { display: flex; gap: 8px; border-bottom: 2px solid #e5e5e5; margin-bottom: 20px; }
    .tab { padding: 10px 16px; background: transparent; border: none; border-bottom: 2px solid transparent; cursor: pointer; font-size: 13px; color: #666; transition: all 0.2s; margin-bottom: -2px; }
    .tab:hover { color: #333; }
    .tab.active { color: #4a90e2; border-bottom-color: #4a90e2; font-weight: 600; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    /* Logs */
    .logs-container { max-height: 500px; overflow-y: auto; border: 1px solid #e5e5e5; border-radius: 8px; background: #fafafa; }
    .log-entry { border-bottom: 1px solid #e5e5e5; }
    .log-entry:last-child { border-bottom: none; }
    .log-header { padding: 10px 12px; background: #fff; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background 0.2s; }
    .log-header:hover { background: #f5f5f5; }
    .log-header-left { display: flex; align-items: center; gap: 10px; flex: 1; }
    .log-time { font-size: 11px; color: #999; font-family: monospace; }
    .log-type { font-size: 11px; padding: 2px 8px; border-radius: 4px; font-weight: 600; }
    .log-type.request { background: #e3f2fd; color: #1976d2; }
    .log-type.response { background: #e8f5e9; color: #388e3c; }
    .log-type.error { background: #ffebee; color: #d32f2f; }
    .log-type.info { background: #fff3e0; color: #f57c00; }
    .log-title { font-size: 12px; color: #333; flex: 1; }
    .log-toggle { font-size: 12px; color: #999; }
    .log-body { padding: 12px; background: #fff; display: none; font-family: monospace; font-size: 11px; line-height: 1.6; white-space: pre-wrap; word-break: break-all; border-top: 1px solid #f0f0f0; }
    .log-body.open { display: block; }
    .log-body pre { margin: 0; }
    .log-actions { display: flex; justify-content: space-between; align-items: center; gap: 8px; padding: 12px; border-top: 1px solid #e5e5e5; background: #fff; }
    .log-actions-left { display: flex; gap: 8px; }
    .log-actions-right { display: flex; gap: 8px; align-items: center; }
    .btn-clear-logs { padding: 6px 12px; background: #f44336; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; }
    .btn-clear-logs:hover { background: #d32f2f; }
    .btn-export-logs { padding: 6px 12px; background: #4a90e2; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; }
    .btn-export-logs:hover { background: #357abd; }
    .btn-copy-all-logs { padding: 6px 12px; background: #4caf50; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; display: inline-flex; align-items: center; gap: 6px; }
    .btn-copy-all-logs:hover { background: #45a049; }
    .btn-copy-log { padding: 4px 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 11px; color: #666; display: inline-flex; align-items: center; gap: 4px; }
    .btn-copy-log:hover { background: #f5f5f5; border-color: #4a90e2; color: #4a90e2; }
    .log-actions-right { display: flex; gap: 6px; align-items: center; }
    
    /* Animations */
    @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.5} }
    @keyframes slideDown { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
    
    /* Mobile */
    @media(max-width: 900px){ 
      .layout { flex-direction: column; }
      .sidebar { width: 100%; }
      .steps-list { flex-direction: row; overflow-x: auto; max-height: none; }
      .step-item { flex-shrink: 0; min-width: 120px; }
      .chain-diagram { justify-content: flex-start; }
    }

    /* Mobile-only elements */
    .mobile-only { display: none; }
    @media(max-width: 900px) {
      /* Elements marked mobile-only only appear on small viewports */
      .mobile-only { display: inline-flex; }
    }

    /* Retry icon after error */
    .retry-icon {
      background: none;
      border: none;
      color: #4a90e2;
      cursor: pointer;
      font-size: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-right: 4px;
    }
    .retry-icon:hover {
      color: #357abd;
    }

  </style>
</head>
<body>
  <div id="app">
    <header class="header">
      <div class="header-title">Ù…Ø±Ø¨ÛŒ ØªÙÚ©Ø± ØªØ¹Ø§ÙˆÙ† Ø¢ÙØ±ÛŒÙ†ÛŒ</div>
      <div class="header-actions">
        <!-- ØªÙ†Ø¸ÛŒÙ…Ø§Øª -->
        <button id="settings-btn" class="btn-icon" title="ØªÙ†Ø¸ÛŒÙ…Ø§Øª">âš™ï¸</button>
        <!-- Ø¯Ú©Ù…Ù‡ Ø¬Ù…Ø¹/Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† ÙˆØ±ÙˆØ¯ÛŒ (ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ù…ÙˆØ¨Ø§ÛŒÙ„) -->
        <button id="toggle-input-btn" class="btn-icon mobile-only" title="Ø¬Ù…Ø¹/Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† ÙˆØ±ÙˆØ¯ÛŒ">âŒ¨ï¸</button>
      </div>
    </header>
    
    <div id="input-collapsed-bar" class="input-collapsed-bar">
      <span class="input-preview" id="input-preview">Ø¯ØºØ¯ØºÙ‡ Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯...</span>
      <span>âœï¸</span>
    </div>
    
    <main class="layout">
      <aside class="sidebar">
        <section class="panel">
          <div class="input-label">Ø¯ØºØ¯ØºÙ‡ ÛŒØ§ Ø§ÛŒØ¯Ù‡ Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯:</div>
          <textarea id="user-idea" placeholder="Ù…Ø«Ø§Ù„: Ù‡Ù…Ø§Ù‡Ù†Ú¯ÛŒ Ù†ÛŒØ±ÙˆÙ‡Ø§ÛŒ Ù…Ø³Ø¬Ø¯ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¬Ù‡Ø§Ø¯ÛŒ Ù…Ø­Ù„Ù‡..."></textarea>
          <div class="input-actions">
            <button id="run-btn" class="btn-primary">Ø´Ø±ÙˆØ¹ ØªØ­Ù„ÛŒÙ„</button>
          </div>
        </section>
        <section class="panel">
          <div class="steps-title">Ù…Ø±Ø§Ø­Ù„ Ø¹Ù…Ù„ÛŒØ§Øª</div>
          <ul id="steps-list" class="steps-list"></ul>
        </section>
      </aside>
      <section class="content">
        <div id="placeholder" class="placeholder">Ø¯ØºØ¯ØºÙ‡ Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯ Ùˆ Â«Ø´Ø±ÙˆØ¹ ØªØ­Ù„ÛŒÙ„Â» Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯.</div>
        <div id="ops"></div>
      </section>
    </main>
  </div>
  
  <!-- Settings Modal -->
  <div id="settings-modal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">ØªÙ†Ø¸ÛŒÙ…Ø§Øª</div>
        <button id="modal-close" class="modal-close">Ã—</button>
      </div>
      <div class="modal-body">
        <div class="tabs">
          <button class="tab active" data-tab="prompts">Ù¾Ø±Ø§Ù…Ù¾Øªâ€ŒÙ‡Ø§</button>
          <!-- Ø­Ø°Ù Ø²Ø¨Ø§Ù†Ù‡Ù” Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ù„ÛŒØ¯Ù‡Ø§ØŒ Ú©Ù„ÛŒØ¯Ù‡Ø§ Ø§Ø² Ù…Ø­ÛŒØ· Ø§Ø¬Ø±Ø§ Ø®ÙˆØ§Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ -->
          <button class="tab" data-tab="logs">Ù„Ø§Ú¯â€ŒÙ‡Ø§</button>
        </div>
        
        <!-- Prompts Tab -->
        <div id="tab-prompts" class="tab-content active">
          <div class="setting-group">
            <div class="setting-label">Ù…Ø¯Ù„ ØªÙÚ©Ø± (Thinking)</div>
            <div class="setting-desc">Ù…Ø¯Ù„ Ø¨Ø±Ø§ÛŒ Ù…Ø±Ø­Ù„Ù‡ ØªÙÚ©Ø± Ùˆ Ù¾Ø±Ø¯Ø§Ø²Ø´</div>
            <select id="model-thinking">
              <option value="gemini-2.0-flash-thinking-exp-01-21">Gemini 2.0 Flash Thinking</option>
              <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash</option>
              <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
            </select>
          </div>
          <div class="setting-group">
            <div class="setting-label">Ù…Ø¯Ù„ Ø®Ø±ÙˆØ¬ÛŒ (Output)</div>
            <div class="setting-desc">Ù…Ø¯Ù„ Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ Ø®Ø±ÙˆØ¬ÛŒ Ù†Ù‡Ø§ÛŒÛŒ</div>
            <select id="model-output">
              <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
              <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash</option>
            </select>
          </div>
          <div class="setting-group">
            <div class="setting-label">Ù…Ø±Ø§Ø­Ù„ Ø¹Ù…Ù„ÛŒØ§Øª</div>
            <div class="setting-desc">Ù…Ø¯ÛŒØ±ÛŒØª Ùˆ ÙˆÛŒØ±Ø§ÛŒØ´ Ù…Ø±Ø§Ø­Ù„ Ø¹Ù…Ù„ÛŒØ§Øª</div>
            <div id="steps-cards-container" class="steps-cards-container"></div>
            <button id="add-step-btn" class="btn-add-step">
              <span>+</span>
              <span>Ø§ÙØ²ÙˆØ¯Ù† Ù…Ø±Ø­Ù„Ù‡ Ø¬Ø¯ÛŒØ¯</span>
            </button>
          </div>
          <div class="setting-group">
            <div class="setting-label">Ù¾Ø±Ø§Ù…Ù¾Øª Ø³ÛŒØ³ØªÙ…</div>
            <textarea id="system-prompt" class="setting-textarea"></textarea>
          </div>
          <button id="save-settings" class="btn-save">Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª</button>
        </div>
        
        <!-- API Keys Tab Ø­Ø°Ù Ø´Ø¯ -->
        
        <!-- Logs Tab -->
        <div id="tab-logs" class="tab-content">
          <div class="setting-group">
            <div class="setting-label">Ù„Ø§Ú¯â€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ…</div>
            <div class="setting-desc">ØªÙ…Ø§Ù… Ø¯Ø±Ø®ÙˆØ§Ø³Øªâ€ŒÙ‡Ø§ØŒ Ù¾Ø§Ø³Ø®â€ŒÙ‡Ø§ Ùˆ Ø®Ø·Ø§Ù‡Ø§</div>
            <div class="logs-container" id="logs-container"></div>
            <div class="log-actions">
              <div class="log-actions-left">
                <button id="clear-logs-btn" class="btn-clear-logs">Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù„Ø§Ú¯â€ŒÙ‡Ø§</button>
                <button id="export-logs-btn" class="btn-export-logs">Ø¯Ø§Ù†Ù„ÙˆØ¯ Ù„Ø§Ú¯â€ŒÙ‡Ø§</button>
              </div>
              <div class="log-actions-right">
                <button id="copy-all-logs-btn" class="btn-copy-all-logs">
                  <span>ğŸ“‹</span>
                  <span>Ú©Ù¾ÛŒ Ù‡Ù…Ù‡ Ù„Ø§Ú¯â€ŒÙ‡Ø§</span>
                </button>
              </div>
      </div>
    </div>
    </div>
      </div>
    </div>
  </div>

  <script src="env.js"></script>
  <script>
    // Default Configuration
    // Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ API Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù…ØªØºÛŒØ± Ù…Ø­ÛŒØ·ÛŒ Ø§Ø² window.TAAVON_API_KEYS Ø®ÙˆØ§Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.
    const DEFAULT_CONFIG = {
      // API keys are injected via a Cloudflare environment variable.  This value can be
      // either an array or a commaâ€‘separated string.  Parse into an array of nonâ€‘empty strings.
      apiKeys:
        Array.isArray(window.TAAVON_API_KEYS)
          ? window.TAAVON_API_KEYS
          : typeof window.TAAVON_API_KEYS === "string"
          ? window.TAAVON_API_KEYS.split(",").map(k => k.trim()).filter(Boolean)
          : [],
      modelThinking: "gemini-2.0-flash-thinking-exp-01-21",
      modelOutput: "gemini-2.5-pro",
      systemPrompt: "ØªÙˆ ÛŒÚ© Â«Ù…Ø±Ø¨ÛŒ ØªÙÚ©Ø± ØªØ¹Ø§ÙˆÙ† Ø¢ÙØ±ÛŒÙ†ÛŒÂ» Ù‡Ø³ØªÛŒ. Ø®Ø±ÙˆØ¬ÛŒ Ø±Ø§ Ø¨Ù‡ ÙØ§Ø±Ø³ÛŒ Ø¨Ø¯Ù‡.",
      steps: [
        { id: "analysis", title: "ØªØ­Ù„ÛŒÙ„ Ø¯ØºØ¯ØºÙ‡ Ùˆ Ø¨Ø§Ø²ØªØ¹Ø±ÛŒÙ Ø¨Ù‡ Ø¨Ø³ØªØ± ØªØ¹Ø§ÙˆÙ†", resultLabel: "Ø¨Ø§Ø²ØªØ¹Ø±ÛŒÙ Ø¯ØºØ¯ØºÙ‡", thinkingLabel: "Ø¯Ø± Ø­Ø§Ù„ ØªÙÚ©Ø± Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²ØªØ¹Ø±ÛŒÙ Ù…Ø³Ø¦Ù„Ù‡" },
        { id: "value_chain", title: "Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø²Ù†Ø¬ÛŒØ±Ù‡ Ø§Ø±Ø²Ø´", resultLabel: "Ù†Ù…ÙˆØ¯Ø§Ø± Ø²Ù†Ø¬ÛŒØ±Ù‡ Ø§Ø±Ø²Ø´", thinkingLabel: "Ø¯Ø± Ø­Ø§Ù„ ØªÙÚ©Ø± Ø¨Ø±Ø§ÛŒ Ø·Ø±Ø§Ø­ÛŒ Ø²Ù†Ø¬ÛŒØ±Ù‡ Ø§Ø±Ø²Ø´" },
        { id: "canvas", title: "Ù¾Ø± Ú©Ø±Ø¯Ù† Ø¨ÙˆÙ… ØªØ¹Ø§ÙˆÙ† Ø¢ÙØ±ÛŒÙ†ÛŒ", resultLabel: "Ø¨ÙˆÙ… ØªØ¹Ø§ÙˆÙ† Ø¢ÙØ±ÛŒÙ†ÛŒ", thinkingLabel: "Ø¯Ø± Ø­Ø§Ù„ ØªÙÚ©Ø± Ø¨Ø±Ø§ÛŒ Ù¾Ø± Ú©Ø±Ø¯Ù† Ø¨ÙˆÙ…" },
        { id: "infographic", title: "Ø·Ø±Ø§Ø­ÛŒ Ø§ÛŒÙ†ÙÙˆÚ¯Ø±Ø§ÙÛŒÚ©", resultLabel: "Ø§ÛŒÙ†ÙÙˆÚ¯Ø±Ø§ÙÛŒÚ© Ø¨Ø³ØªØ± ØªØ¹Ø§ÙˆÙ†", thinkingLabel: "Ø¯Ø± Ø­Ø§Ù„ ØªÙÚ©Ø± Ø¨Ø±Ø§ÛŒ Ø·Ø±Ø§Ø­ÛŒ Ø§ÛŒÙ†ÙÙˆÚ¯Ø±Ø§ÙÛŒÚ©" },
        { id: "checklist", title: "ÙØ±Ù…Ø§Ù† Ø¹Ù…Ù„ÛŒØ§Øª", resultLabel: "Ú†Ú©â€ŒÙ„ÛŒØ³Øª Ø¹Ù…Ù„ÛŒØ§Øª", thinkingLabel: "Ø¯Ø± Ø­Ø§Ù„ ØªÙÚ©Ø± Ø¨Ø±Ø§ÛŒ ØªØ¯ÙˆÛŒÙ† ÙØ±Ù…Ø§Ù† Ø¹Ù…Ù„ÛŒØ§Øª" }
      ]
    };

    // Load/Save Config
    function loadConfig() {
      const saved = localStorage.getItem('taavon_config');
      // Always prioritise DEFAULT_CONFIG.apiKeys (from environment) over any saved keys.
      if (saved) {
        const parsed = JSON.parse(saved);
        return { ...DEFAULT_CONFIG, ...parsed, apiKeys: DEFAULT_CONFIG.apiKeys };
      }
      return DEFAULT_CONFIG;
    }
    function saveConfig(config) {
      localStorage.setItem('taavon_config', JSON.stringify(config));
    }
    
    // Load/Save API Key Stats
    function loadKeyStats() {
      const saved = localStorage.getItem('taavon_key_stats');
      return saved ? JSON.parse(saved) : {};
    }
    function saveKeyStats(stats) {
      localStorage.setItem('taavon_key_stats', JSON.stringify(stats));
    }
    
    // Logging System
    const MAX_LOGS = 500; // Keep last 500 logs
    function loadLogs() {
      const saved = localStorage.getItem('taavon_logs');
      return saved ? JSON.parse(saved) : [];
    }
    function saveLogs(logs) {
      // Keep only last MAX_LOGS
      const trimmed = logs.slice(-MAX_LOGS);
      localStorage.setItem('taavon_logs', JSON.stringify(trimmed));
    }
    
    function addLog(type, title, data = null, error = null) {
      const log = {
        id: Date.now() + Math.random(),
        timestamp: new Date().toISOString(),
        type, // 'request', 'response', 'error', 'info'
        title,
        data: data ? (typeof data === 'string' ? data : JSON.stringify(data, null, 2)) : null,
        error: error ? (error.message || String(error)) : null
      };
      
      const logs = loadLogs();
      logs.push(log);
      saveLogs(logs);
      
      // Update UI if logs tab is active
      if (document.getElementById('tab-logs')?.classList.contains('active')) {
        renderLogs();
      }
    }
    
    function renderLogs() {
      const container = document.getElementById('logs-container');
      if (!container) return;
      
      const logs = loadLogs();
      container.innerHTML = '';
      
      if (logs.length === 0) {
        container.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">Ù„Ø§Ú¯ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯</div>';
        return;
      }
      
      // Show newest first
      logs.slice().reverse().forEach(log => {
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        
        const header = document.createElement('div');
        header.className = 'log-header';
        
        const left = document.createElement('div');
        left.className = 'log-header-left';
        
        const time = document.createElement('span');
        time.className = 'log-time';
        const date = new Date(log.timestamp);
        time.textContent = date.toLocaleTimeString('fa-IR') + ' ' + date.toLocaleDateString('fa-IR');
        
        const typeBadge = document.createElement('span');
        typeBadge.className = 'log-type ' + log.type;
        const typeLabels = {
          request: 'Ø¯Ø±Ø®ÙˆØ§Ø³Øª',
          response: 'Ù¾Ø§Ø³Ø®',
          error: 'Ø®Ø·Ø§',
          info: 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª'
        };
        typeBadge.textContent = typeLabels[log.type] || log.type;
        
        const title = document.createElement('span');
        title.className = 'log-title';
        title.textContent = log.title;
        
        const toggle = document.createElement('span');
        toggle.className = 'log-toggle';
        toggle.textContent = 'â–¾';
        
        // Copy button for individual log
        const copyBtn = document.createElement('button');
        copyBtn.className = 'btn-copy-log';
        copyBtn.innerHTML = 'ğŸ“‹';
        copyBtn.title = 'Ú©Ù¾ÛŒ Ø§ÛŒÙ† Ù„Ø§Ú¯';
        copyBtn.onclick = (e) => {
          e.stopPropagation();
          const logText = [
            `Ø²Ù…Ø§Ù†: ${date.toLocaleTimeString('fa-IR')} ${date.toLocaleDateString('fa-IR')}`,
            `Ù†ÙˆØ¹: ${typeLabels[log.type] || log.type}`,
            `Ø¹Ù†ÙˆØ§Ù†: ${log.title}`,
            log.error ? `Ø®Ø·Ø§: ${log.error}` : '',
            log.data ? `\nØ¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§:\n${log.data}` : ''
          ].filter(Boolean).join('\n');
          
          navigator.clipboard.writeText(logText).then(() => {
            copyBtn.innerHTML = 'âœ“';
            copyBtn.style.color = '#4caf50';
            setTimeout(() => {
              copyBtn.innerHTML = 'ğŸ“‹';
              copyBtn.style.color = '';
            }, 2000);
          }).catch(() => {
            // Fallback for older browsers
            const textarea = document.createElement('textarea');
            textarea.value = logText;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            copyBtn.innerHTML = 'âœ“';
            copyBtn.style.color = '#4caf50';
            setTimeout(() => {
              copyBtn.innerHTML = 'ğŸ“‹';
              copyBtn.style.color = '';
            }, 2000);
          });
        };
        
        const right = document.createElement('div');
        right.className = 'log-actions-right';
        right.append(copyBtn, toggle);
        
        left.append(time, typeBadge, title);
        header.append(left, right);
        
        const body = document.createElement('div');
        body.className = 'log-body';
        
        if (log.error) {
          const errorDiv = document.createElement('div');
          errorDiv.style.color = '#d32f2f';
          errorDiv.style.marginBottom = '8px';
          errorDiv.textContent = 'Ø®Ø·Ø§: ' + log.error;
          body.appendChild(errorDiv);
        }
        
        if (log.data) {
          const pre = document.createElement('pre');
          pre.textContent = log.data;
          body.appendChild(pre);
        }
        
        entry.append(header, body);
        
        header.addEventListener('click', () => {
          body.classList.toggle('open');
          toggle.textContent = body.classList.contains('open') ? 'â–´' : 'â–¾';
        });
        
        container.appendChild(entry);
      });
    }
    
    let config = loadConfig();
    let keyStats = loadKeyStats();
    let currentKeyIndex = 0;
    let activeKeys = new Set(); // Track currently active keys
    
    // Initialize stats for new keys
    config.apiKeys.forEach(key => {
      if (!keyStats[key]) {
        keyStats[key] = { total: 0, success: 0, error: 0, lastUsed: null };
      }
    });
    saveKeyStats(keyStats);
    
    // Request Queue Manager with exponential backoff
    class RequestQueue {
      constructor(delayMs = 2000) {
        this.queue = [];
        this.processing = false;
        this.delay = delayMs;
        this.lastRequestTime = 0;
      }
      
      async add(requestFn) {
        return new Promise((resolve, reject) => {
          this.queue.push({ requestFn, resolve, reject });
          this.process();
        });
      }
      
      async process() {
        if (this.processing || this.queue.length === 0) return;
        this.processing = true;
        
        while (this.queue.length > 0) {
          const { requestFn, resolve, reject } = this.queue.shift();
          
          // Ensure minimum delay since last request
          const timeSinceLastRequest = Date.now() - this.lastRequestTime;
          if (timeSinceLastRequest < this.delay) {
            await new Promise(r => setTimeout(r, this.delay - timeSinceLastRequest));
          }
          
          try {
            this.lastRequestTime = Date.now();
            const result = await requestFn();
            resolve(result);
          } catch (error) {
            reject(error);
          }
          
          // Delay between requests to avoid rate limiting
          if (this.queue.length > 0) {
            await new Promise(r => setTimeout(r, this.delay));
          }
        }
        
        this.processing = false;
      }
    }
    
    const requestQueue = new RequestQueue(2000); // 2 second delay between requests to avoid rate limiting
    
    // Rate limit tracking for API keys
    const rateLimitedKeys = new Map(); // key -> timestamp when rate limit expires
    
    // DOM Elements
    const userIdea = document.getElementById("user-idea");
    const runBtn = document.getElementById("run-btn");
    const stepsList = document.getElementById("steps-list");
    const ops = document.getElementById("ops");
    const placeholder = document.getElementById("placeholder");
    const inputCollapsedBar = document.getElementById("input-collapsed-bar");
    const inputPreview = document.getElementById("input-preview");
    const toggleInputBtn = document.getElementById("toggle-input-btn");
    const settingsBtn = document.getElementById("settings-btn");
    const settingsModal = document.getElementById("settings-modal");
    const modalClose = document.getElementById("modal-close");
    
    // Tab Switching (Ù¾Ø±Ø§Ù…Ù¾Øª Ùˆ Ù„Ø§Ú¯â€ŒÙ‡Ø§)
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;
        // Update tabs
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        // Update content
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(`tab-${tabName}`).classList.add('active');
        // Load content if needed
        if (tabName === 'logs') {
          renderLogs();
        }
      });
    });
    
    // Steps Cards Management
    function renderStepsCards() {
      const container = document.getElementById("steps-cards-container");
      container.innerHTML = "";
      
      config.steps.forEach((step, index) => {
        const card = createStepCard(step, index);
        container.appendChild(card);
      });
    }
    
    function createStepCard(step, index) {
      const card = document.createElement("div");
      card.className = "step-card";
      card.dataset.index = index;
      
      const isEditing = card.dataset.editing === "true";
      
      // Header
      const header = document.createElement("div");
      header.className = "step-card-header";
      
      const number = document.createElement("div");
      number.className = "step-card-number";
      number.textContent = index + 1;
      
      const title = document.createElement("div");
      title.className = "step-card-title";
      title.textContent = step.title || "Ù…Ø±Ø­Ù„Ù‡ Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†";
      
      const actions = document.createElement("div");
      actions.className = "step-card-actions";
      
      // Drag handle
      const dragHandle = document.createElement("button");
      dragHandle.className = "btn-card-action step-card-drag-handle";
      dragHandle.title = "ØªØºÛŒÛŒØ± ØªØ±ØªÛŒØ¨";
      dragHandle.innerHTML = "â‹®â‹®";
      dragHandle.onclick = (e) => {
        e.stopPropagation();
        // Simple move up/down for now
      };
      
      // Move up button
      const moveUpBtn = document.createElement("button");
      moveUpBtn.className = "btn-card-action";
      moveUpBtn.title = "Ø¬Ø§Ø¨Ø¬Ø§ÛŒÛŒ Ø¨Ù‡ Ø¨Ø§Ù„Ø§";
      moveUpBtn.innerHTML = "â†‘";
      moveUpBtn.disabled = index === 0;
      moveUpBtn.onclick = (e) => {
        e.stopPropagation();
        moveStep(index, index - 1);
      };
      
      // Move down button
      const moveDownBtn = document.createElement("button");
      moveDownBtn.className = "btn-card-action";
      moveDownBtn.title = "Ø¬Ø§Ø¨Ø¬Ø§ÛŒÛŒ Ø¨Ù‡ Ù¾Ø§ÛŒÛŒÙ†";
      moveDownBtn.innerHTML = "â†“";
      moveDownBtn.disabled = index === config.steps.length - 1;
      moveDownBtn.onclick = (e) => {
        e.stopPropagation();
        moveStep(index, index + 1);
      };
      
      // Edit button
      const editBtn = document.createElement("button");
      editBtn.className = "btn-card-action";
      editBtn.title = "ÙˆÛŒØ±Ø§ÛŒØ´";
      editBtn.innerHTML = "âœï¸";
      editBtn.onclick = (e) => {
        e.stopPropagation();
        toggleEditStep(card, step, index);
      };
      
      // Delete button
      const deleteBtn = document.createElement("button");
      deleteBtn.className = "btn-card-action danger";
      deleteBtn.title = "Ø­Ø°Ù";
      deleteBtn.innerHTML = "ğŸ—‘ï¸";
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        if (confirm(`Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ù…Ø±Ø­Ù„Ù‡ "${step.title}" Ø±Ø§ Ø­Ø°Ù Ú©Ù†ÛŒØ¯ØŸ`)) {
          deleteStep(index);
        }
      };
      
      actions.append(moveUpBtn, moveDownBtn, editBtn, deleteBtn);
      header.append(number, title, actions);
      
      // Content (view mode)
      const viewContent = document.createElement("div");
      viewContent.className = "step-card-view";
      
      const viewItems = [
        { label: "Ø´Ù†Ø§Ø³Ù‡", value: step.id },
        { label: "Ø¹Ù†ÙˆØ§Ù†", value: step.title },
        { label: "Ø¨Ø±Ú†Ø³Ø¨ Ù†ØªÛŒØ¬Ù‡", value: step.resultLabel },
        { label: "Ø¨Ø±Ú†Ø³Ø¨ ØªÙÚ©Ø±", value: step.thinkingLabel }
      ];
      
      viewItems.forEach(item => {
        const viewItem = document.createElement("div");
        viewItem.className = "step-card-view-item";
        const label = document.createElement("div");
        label.className = "step-card-view-label";
        label.textContent = item.label;
        const value = document.createElement("div");
        value.className = "step-card-view-value";
        value.textContent = item.value || "-";
        viewItem.append(label, value);
        viewContent.appendChild(viewItem);
      });
      
      // Content (edit mode)
      const editContent = document.createElement("div");
      editContent.className = "step-card-fields";
      editContent.style.display = "none";
      
      const idField = createField("Ø´Ù†Ø§Ø³Ù‡ (ID)", "id", step.id, true);
      const titleField = createField("Ø¹Ù†ÙˆØ§Ù†", "title", step.title);
      const resultLabelField = createField("Ø¨Ø±Ú†Ø³Ø¨ Ù†ØªÛŒØ¬Ù‡", "resultLabel", step.resultLabel);
      const thinkingLabelField = createField("Ø¨Ø±Ú†Ø³Ø¨ ØªÙÚ©Ø±", "thinkingLabel", step.thinkingLabel);
      
      editContent.append(idField, titleField, resultLabelField, thinkingLabelField);
      
      // Save/Cancel buttons
      const editActions = document.createElement("div");
      editActions.className = "step-card-actions";
      editActions.style.marginTop = "12px";
      editActions.style.display = "none";
      
      const saveBtn = document.createElement("button");
      saveBtn.className = "btn-save";
      saveBtn.textContent = "Ø°Ø®ÛŒØ±Ù‡";
      saveBtn.onclick = (e) => {
        e.stopPropagation();
        saveStepEdit(card, index);
      };
      
      const cancelBtn = document.createElement("button");
      cancelBtn.className = "btn-card-action";
      cancelBtn.textContent = "Ù„ØºÙˆ";
      cancelBtn.onclick = (e) => {
        e.stopPropagation();
        toggleEditStep(card, step, index);
      };
      
      editActions.append(saveBtn, cancelBtn);
      
      card.append(header, viewContent, editContent, editActions);
      
      return card;
    }
    
    function createField(label, name, value, readonly = false) {
      const field = document.createElement("div");
      field.className = `step-card-field ${name === 'id' ? '' : ''}`;
      
      const labelEl = document.createElement("div");
      labelEl.className = "step-card-field-label";
      labelEl.textContent = label;
      
      const input = document.createElement("input");
      input.type = "text";
      input.className = "step-card-field-input";
      input.name = name;
      input.value = value || "";
      if (readonly) {
        input.readOnly = true;
      }
      
      field.append(labelEl, input);
      return field;
    }
    
    function toggleEditStep(card, step, index) {
      const isEditing = card.dataset.editing === "true";
      const viewContent = card.querySelector(".step-card-view");
      const editContent = card.querySelector(".step-card-fields");
      const editActions = card.querySelector(".step-card-actions:last-of-type");
      const title = card.querySelector(".step-card-title");
      
      // Get current step from config (might have been updated)
      const currentStep = config.steps[index];
      
      if (isEditing) {
        // Switch to view mode - cancel changes
        card.dataset.editing = "false";
        card.classList.remove("editing");
        viewContent.style.display = "grid";
        editContent.style.display = "none";
        editActions.style.display = "none";
        title.textContent = currentStep.title || "Ù…Ø±Ø­Ù„Ù‡ Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†";
        
        // Update view content with current values
        const viewItems = viewContent.querySelectorAll(".step-card-view-item");
        if (viewItems.length >= 4) {
          viewItems[0].querySelector(".step-card-view-value").textContent = currentStep.id || "-";
          viewItems[1].querySelector(".step-card-view-value").textContent = currentStep.title || "-";
          viewItems[2].querySelector(".step-card-view-value").textContent = currentStep.resultLabel || "-";
          viewItems[3].querySelector(".step-card-view-value").textContent = currentStep.thinkingLabel || "-";
        }
      } else {
        // Switch to edit mode
        card.dataset.editing = "true";
        card.classList.add("editing");
        viewContent.style.display = "none";
        editContent.style.display = "grid";
        editActions.style.display = "flex";
        
        // Populate fields with current values
        editContent.querySelector(`input[name="id"]`).value = currentStep.id || "";
        editContent.querySelector(`input[name="title"]`).value = currentStep.title || "";
        editContent.querySelector(`input[name="resultLabel"]`).value = currentStep.resultLabel || "";
        editContent.querySelector(`input[name="thinkingLabel"]`).value = currentStep.thinkingLabel || "";
      }
    }
    
    function saveStepEdit(card, index) {
      const fields = card.querySelectorAll(".step-card-field-input");
      const step = {
        id: fields[0].value.trim() || `step_${Date.now()}`,
        title: fields[1].value.trim() || "Ù…Ø±Ø­Ù„Ù‡ Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†",
        resultLabel: fields[2].value.trim() || "",
        thinkingLabel: fields[3].value.trim() || ""
      };
      
      config.steps[index] = step;
      renderStepsCards();
      
      // Scroll to the updated card
      setTimeout(() => {
        const cards = document.querySelectorAll(".step-card");
        if (cards[index]) {
          cards[index].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }, 50);
    }
    
    function deleteStep(index) {
      config.steps.splice(index, 1);
      renderStepsCards();
    }
    
    function moveStep(fromIndex, toIndex) {
      if (toIndex < 0 || toIndex >= config.steps.length) return;
      
      const step = config.steps.splice(fromIndex, 1)[0];
      config.steps.splice(toIndex, 0, step);
      renderStepsCards();
    }
    
    function addNewStep() {
      const newStep = {
        id: `step_${Date.now()}`,
        title: "Ù…Ø±Ø­Ù„Ù‡ Ø¬Ø¯ÛŒØ¯",
        resultLabel: "Ù†ØªÛŒØ¬Ù‡",
        thinkingLabel: "Ø¯Ø± Ø­Ø§Ù„ ØªÙÚ©Ø±..."
      };
      
      config.steps.push(newStep);
      renderStepsCards();
      
      // Auto-edit the new step
      setTimeout(() => {
        const cards = document.querySelectorAll(".step-card");
        const lastCard = cards[cards.length - 1];
        if (lastCard) {
          const lastIndex = config.steps.length - 1;
          toggleEditStep(lastCard, config.steps[lastIndex], lastIndex);
        }
      }, 100);
    }
    
    // Settings UI
    settingsBtn.addEventListener("click", () => {
      document.getElementById("model-thinking").value = config.modelThinking;
      document.getElementById("model-output").value = config.modelOutput;
      renderStepsCards();
      document.getElementById("system-prompt").value = config.systemPrompt;
      // Ø¯Ø± Ø§ÛŒÙ† Ù†Ø³Ø®Ù‡ Ø±Ø§Ø¨Ø· Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ù„ÛŒØ¯Ù‡Ø§ Ø­Ø°Ù Ø´Ø¯Ù‡ Ø§Ø³ØªØŒ Ø¨Ù†Ø§Ø¨Ø±Ø§ÛŒÙ† Ù†ÛŒØ§Ø²ÛŒ Ø¨Ù‡ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢Ù…Ø§Ø± Ú©Ù„ÛŒØ¯Ù‡Ø§ Ù†ÛŒØ³Øª
      renderLogs();
      settingsModal.classList.add("active");
    });
    
    // Add step button
    document.getElementById("add-step-btn").addEventListener("click", addNewStep);
    
    // Clear Logs
    document.getElementById("clear-logs-btn").addEventListener("click", () => {
      if (confirm("Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ù‡Ù…Ù‡ Ù„Ø§Ú¯â€ŒÙ‡Ø§ Ø±Ø§ Ù¾Ø§Ú© Ú©Ù†ÛŒØ¯ØŸ")) {
        localStorage.removeItem('taavon_logs');
        renderLogs();
      }
    });
    
    // Export Logs
    document.getElementById("export-logs-btn").addEventListener("click", () => {
      const logs = loadLogs();
      const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `taavon-logs-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
    
    // Copy All Logs
    document.getElementById("copy-all-logs-btn").addEventListener("click", () => {
      const logs = loadLogs();
      const typeLabels = {
        request: 'Ø¯Ø±Ø®ÙˆØ§Ø³Øª',
        response: 'Ù¾Ø§Ø³Ø®',
        error: 'Ø®Ø·Ø§',
        info: 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª'
      };
      
      const allLogsText = logs.map(log => {
        const date = new Date(log.timestamp);
        const lines = [
          `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`,
          `Ø²Ù…Ø§Ù†: ${date.toLocaleTimeString('fa-IR')} ${date.toLocaleDateString('fa-IR')}`,
          `Ù†ÙˆØ¹: ${typeLabels[log.type] || log.type}`,
          `Ø¹Ù†ÙˆØ§Ù†: ${log.title}`,
          log.error ? `Ø®Ø·Ø§: ${log.error}` : '',
          log.data ? `\nØ¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§:\n${log.data}` : ''
        ].filter(Boolean);
        return lines.join('\n');
      }).join('\n\n');
      
      navigator.clipboard.writeText(allLogsText).then(() => {
        const btn = document.getElementById("copy-all-logs-btn");
        const originalHTML = btn.innerHTML;
        btn.innerHTML = '<span>âœ“</span><span>Ú©Ù¾ÛŒ Ø´Ø¯!</span>';
        btn.style.background = '#4caf50';
        setTimeout(() => {
          btn.innerHTML = originalHTML;
          btn.style.background = '';
        }, 2000);
      }).catch(() => {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = allLogsText;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        const btn = document.getElementById("copy-all-logs-btn");
        const originalHTML = btn.innerHTML;
        btn.innerHTML = '<span>âœ“</span><span>Ú©Ù¾ÛŒ Ø´Ø¯!</span>';
        btn.style.background = '#4caf50';
        setTimeout(() => {
          btn.innerHTML = originalHTML;
          btn.style.background = '';
        }, 2000);
      });
    });
    
    // Add API Key functionality Ø­Ø°Ù Ø´Ø¯Ù‡ Ø§Ø³Øª. Ø¯Ú©Ù…Ù‡ Ù…Ø±Ø¨ÙˆØ·Ù‡ Ø¯Ø± Ø±Ø§Ø¨Ø· ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.
    
    modalClose.addEventListener("click", () => settingsModal.classList.remove("active"));
    settingsModal.addEventListener("click", (e) => {
      if (e.target === settingsModal) settingsModal.classList.remove("active");
    });
    
    document.getElementById("save-settings").addEventListener("click", () => {
      try {
        config.modelThinking = document.getElementById("model-thinking").value;
        config.modelOutput = document.getElementById("model-output").value;
        // Steps are already updated in config.steps through the card interface
        config.systemPrompt = document.getElementById("system-prompt").value;
        saveConfig(config);
        alert("ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯!");
        settingsModal.classList.remove("active");
      } catch (e) {
        alert("Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡: " + e.message);
      }
    });
    
    // Auto-update logs every 2 seconds when the modal is open
    setInterval(() => {
      if (settingsModal.classList.contains("active")) {
        const activeTab = document.querySelector('.tab.active')?.dataset.tab;
        if (activeTab === 'logs') {
          renderLogs();
        }
      }
    }, 2000);
    
    // Initial log
    addLog('info', 'Ø³ÛŒØ³ØªÙ… Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯', { timestamp: new Date().toISOString() });
    
    // Input Collapse (Mobile)
    function isMobile() { return window.innerWidth <= 900; }
    inputCollapsedBar.addEventListener("click", () => {
      document.body.classList.remove("input-hidden");
      userIdea.focus();
    });
    
    function collapseInput() {
      if (isMobile() && userIdea.value.trim()) {
        document.body.classList.add("input-hidden");
        const preview = userIdea.value.trim().substring(0, 40);
        inputPreview.textContent = preview + (userIdea.value.length > 40 ? "..." : "");
      }
    }

    // Toggle input visibility on mobile by tapping keyboard icon
    if (toggleInputBtn) {
      toggleInputBtn.addEventListener("click", () => {
        if (!isMobile()) return;
        if (document.body.classList.contains("input-hidden")) {
          // Expand the input panel
          document.body.classList.remove("input-hidden");
          userIdea.focus();
        } else {
          // Collapse if there is content
          collapseInput();
        }
      });
    }
    
    // Update API Keys Stats UI
    function updateKeyStatsUI() {
      const list = document.getElementById("api-keys-list");
      if (!list) return;
      
      list.innerHTML = "";
      
      config.apiKeys.forEach((key, index) => {
        const stats = keyStats[key] || { total: 0, success: 0, error: 0, lastUsed: null };
        const successRate = stats.total > 0 ? ((stats.success / stats.total) * 100).toFixed(1) : 0;
        const isActive = activeKeys.has(key);
        
        const card = document.createElement("div");
        card.className = "api-key-card";
        
        const info = document.createElement("div");
        info.className = "api-key-info";
        
        const keyValue = document.createElement("div");
        keyValue.className = "api-key-value";
        keyValue.textContent = key.substring(0, 20) + "..." + key.substring(key.length - 10);
        
        const statsDiv = document.createElement("div");
        statsDiv.className = "api-key-stats";
        
        const totalStat = document.createElement("div");
        totalStat.className = "stat-item";
        totalStat.innerHTML = `<span class="stat-label">Ø§Ø³ØªÙØ§Ø¯Ù‡</span><span class="stat-value">${stats.total}</span>`;
        
        const successStat = document.createElement("div");
        successStat.className = "stat-item";
        successStat.innerHTML = `<span class="stat-label">Ù…ÙˆÙÙ‚</span><span class="stat-value success">${stats.success}</span>`;
        
        const errorStat = document.createElement("div");
        errorStat.className = "stat-item";
        errorStat.innerHTML = `<span class="stat-label">Ø®Ø·Ø§</span><span class="stat-value error">${stats.error}</span>`;
        
        const rateStat = document.createElement("div");
        rateStat.className = "stat-item";
        rateStat.innerHTML = `<span class="stat-label">Ù†Ø±Ø® Ù…ÙˆÙÙ‚ÛŒØª</span><span class="stat-value ${successRate >= 80 ? 'success' : successRate >= 50 ? '' : 'error'}">${successRate}%</span>`;
        
        const activeStat = document.createElement("div");
        activeStat.className = "stat-item";
        activeStat.innerHTML = `<span class="stat-label">ÙˆØ¶Ø¹ÛŒØª</span><span class="stat-value ${isActive ? 'active' : ''}">${isActive ? 'â— ÙØ¹Ø§Ù„' : 'â—‹ ØºÛŒØ±ÙØ¹Ø§Ù„'}</span>`;
        
        statsDiv.append(totalStat, successStat, errorStat, rateStat, activeStat);
        info.append(keyValue, statsDiv);
        
        const actions = document.createElement("div");
        actions.className = "api-key-actions";
        
        const deleteBtn = document.createElement("button");
        deleteBtn.className = "btn-small danger";
        deleteBtn.textContent = "Ø­Ø°Ù";
        deleteBtn.onclick = () => {
          if (confirm("Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ØŸ")) {
            config.apiKeys.splice(index, 1);
            delete keyStats[key];
            saveConfig(config);
            saveKeyStats(keyStats);
            updateKeyStatsUI();
          }
        };
        
        actions.appendChild(deleteBtn);
        card.append(info, actions);
        list.appendChild(card);
      });
    }
    
    // API Call with Queue and Stats Tracking
    async function callGemini(model, prompt) {
      return requestQueue.add(async () => {
        const fullPrompt = config.systemPrompt + "\n\n" + prompt;
        const body = { contents: [{ role: "user", parts: [{ text: fullPrompt }] }] };
        let lastError;

        // If no API keys are configured, fail fast instead of entering a long wait loop.
        if (!config.apiKeys || config.apiKeys.length === 0) {
          const errMsg =
            "Ù‡ÛŒÚ† Ú©Ù„ÛŒØ¯ API ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ú©Ù„ÛŒØ¯Ù‡Ø§ Ø±Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù…ØªØºÛŒØ± Ù…Ø­ÛŒØ·ÛŒ Ù…Ø´Ø®Øµ Ú©Ù†ÛŒØ¯.";
          addLog(
            'error',
            errMsg,
            { model, prompt: prompt.substring(0, 200) }
          );
          throw new Error(errMsg);
        }
        
        // Log request
        addLog('request', `Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ù‡ ${model}`, {
          model,
          prompt: fullPrompt.substring(0, 500) + (fullPrompt.length > 500 ? '...' : ''),
          timestamp: new Date().toISOString()
        });
        
        for (let i = 0; i < config.apiKeys.length; i++) {
          const keyIndex = (currentKeyIndex + i) % config.apiKeys.length;
          const apiKey = config.apiKeys[keyIndex];
          const maskedKey = apiKey.substring(0, 10) + '...' + apiKey.substring(apiKey.length - 5);
          
          // Skip rate-limited keys
          if (rateLimitedKeys.has(apiKey)) {
            const expiryTime = rateLimitedKeys.get(apiKey);
            if (Date.now() < expiryTime) {
              const remainingSeconds = Math.ceil((expiryTime - Date.now()) / 1000);
              addLog('info', `Ú©Ù„ÛŒØ¯ ${maskedKey} Ø¯Ø± Ø­Ø§Ù„ rate limit Ø§Ø³Øª - ${remainingSeconds} Ø«Ø§Ù†ÛŒÙ‡ Ø¨Ø§Ù‚ÛŒ Ù…Ø§Ù†Ø¯Ù‡`, { key: maskedKey, remainingSeconds });
              continue; // Skip this key and try next one
            } else {
              // Rate limit expired, remove from map
              rateLimitedKeys.delete(apiKey);
            }
          }
          
          // Update stats
          if (!keyStats[apiKey]) keyStats[apiKey] = { total: 0, success: 0, error: 0, lastUsed: null };
          keyStats[apiKey].total++;
          keyStats[apiKey].lastUsed = new Date().toISOString();
          activeKeys.add(apiKey);
          saveKeyStats(keyStats);
          updateKeyStatsUI();
          
          addLog('info', `Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² API Key: ${maskedKey}`, { keyIndex, model });
          
          const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
          try {
            const startTime = Date.now();
            const res = await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
            const duration = Date.now() - startTime;
            
            if (!res.ok) {
              const errorText = await res.text().catch(() => '');
              let errorData;
              try {
                errorData = JSON.parse(errorText);
              } catch {
                errorData = { message: errorText || `HTTP ${res.status}` };
              }
              
              addLog('error', `Ø®Ø·Ø§ Ø¯Ø± ${model} Ø¨Ø§ Ú©Ù„ÛŒØ¯ ${maskedKey}`, {
                status: res.status,
                statusText: res.statusText,
                error: errorData,
                duration: duration + 'ms'
              }, new Error(`HTTP ${res.status}: ${errorData.message || res.statusText}`));
              
              if (res.status === 429) {
                // Parse error message to check if it's quota exhaustion or rate limit
                const errorMessage = errorData?.error?.message || errorData?.message || '';
                const isQuotaExceeded = errorMessage.includes('quota') || errorMessage.includes('Quota exceeded');
                
                // Extract retry time from error message (e.g., "Please retry in 59.322608273s")
                let waitSeconds = 60; // Default: wait 60 seconds
                const retryMatch = errorMessage.match(/retry in ([\d.]+)s/i);
                if (retryMatch) {
                  waitSeconds = Math.ceil(parseFloat(retryMatch[1])) || 60;
                } else {
                  // Try Retry-After header if available
                  const retryAfter = res.headers.get('Retry-After');
                  if (retryAfter) {
                    waitSeconds = parseInt(retryAfter, 10) || 60;
                  }
                }
                
                const expiryTime = Date.now() + (waitSeconds * 1000);
                rateLimitedKeys.set(apiKey, expiryTime);
                
                if (isQuotaExceeded) {
                  addLog('error', `Quota ØªÙ…Ø§Ù… Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ú©Ù„ÛŒØ¯ ${maskedKey} - ØµØ¨Ø± ${waitSeconds} Ø«Ø§Ù†ÛŒÙ‡`, { 
                    key: maskedKey, 
                    waitSeconds,
                    errorType: 'quota_exceeded',
                    errorMessage: errorMessage.substring(0, 200)
                  });
                } else {
                  addLog('info', `Rate limit Ø¨Ø±Ø§ÛŒ Ú©Ù„ÛŒØ¯ ${maskedKey} - ØµØ¨Ø± ${waitSeconds} Ø«Ø§Ù†ÛŒÙ‡`, { 
                    key: maskedKey, 
                    waitSeconds,
                    errorType: 'rate_limit'
                  });
                }
                
                // Continue to next key instead of retrying same key
                keyStats[apiKey].error++;
                activeKeys.delete(apiKey);
                saveKeyStats(keyStats);
                updateKeyStatsUI();
                lastError = new Error(`HTTP 429: ${isQuotaExceeded ? 'Quota exceeded' : 'Rate limit exceeded'} for key ${maskedKey}`);
                continue; // Try next key
              }
              throw new Error(`HTTP ${res.status}: ${errorData.message || res.statusText}`);
            }
            
            const data = await res.json();
            const text = data?.candidates?.[0]?.content?.parts?.map(p => p.text || "")?.join("") || "";
            
            // Log response
            addLog('response', `Ù¾Ø§Ø³Ø® Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯ Ø§Ø² ${model}`, {
              model,
              key: maskedKey,
              duration: duration + 'ms',
              responseLength: text.length,
              response: text.substring(0, 1000) + (text.length > 1000 ? '...' : ''),
              fullResponse: text
            });
            
            // Success - clear rate limit if it was set
            if (rateLimitedKeys.has(apiKey)) {
              rateLimitedKeys.delete(apiKey);
              addLog('info', `Ú©Ù„ÛŒØ¯ ${maskedKey} Ø§Ø² rate limit Ø®Ø§Ø±Ø¬ Ø´Ø¯`, { key: maskedKey });
            }
            
            keyStats[apiKey].success++;
            currentKeyIndex = (keyIndex + 1) % config.apiKeys.length;
            activeKeys.delete(apiKey);
            saveKeyStats(keyStats);
            updateKeyStatsUI();
            
            return text;
          } catch (e) {
            keyStats[apiKey].error++;
            activeKeys.delete(apiKey);
            saveKeyStats(keyStats);
            updateKeyStatsUI();
            
            addLog('error', `Ø®Ø·Ø§ Ø¯Ø± ${model}`, {
              key: maskedKey,
              error: e.message,
              stack: e.stack
            }, e);
            
            lastError = e;
          }
        }
        
        // Check if all keys are rate-limited or quota exhausted
        const allKeysRateLimited = config.apiKeys.every(key => {
          if (!rateLimitedKeys.has(key)) return false;
          return Date.now() < rateLimitedKeys.get(key);
        });
        
        if (allKeysRateLimited) {
          // Find the earliest expiry time
          let earliestExpiry = Infinity;
          for (const [key, expiry] of rateLimitedKeys.entries()) {
            if (expiry < earliestExpiry) {
              earliestExpiry = expiry;
            }
          }
          
          const waitTime = Math.max(0, earliestExpiry - Date.now());
          const waitSeconds = Math.ceil(waitTime / 1000);
          
          if (waitTime > 0) {
            addLog('error', `Ù‡Ù…Ù‡ Ú©Ù„ÛŒØ¯Ù‡Ø§ rate limited ÛŒØ§ quota ØªÙ…Ø§Ù… Ø´Ø¯Ù‡ Ù‡Ø³ØªÙ†Ø¯ - Ø§Ù†ØªØ¸Ø§Ø± ${waitSeconds} Ø«Ø§Ù†ÛŒÙ‡`, { 
              waitSeconds,
              earliestExpiry: new Date(earliestExpiry).toISOString(),
              totalKeys: config.apiKeys.length
            });
            await new Promise(r => setTimeout(r, waitTime + 1000)); // Add 1 second buffer
            
            // Retry once after waiting
            return callGemini(model, prompt);
          }
        }
        
        // Check if the error is quota-related
        const isQuotaError = lastError?.message?.includes('Quota exceeded') || 
                            lastError?.message?.includes('quota');
        
        if (isQuotaError) {
          addLog('error', 'Ù‡Ù…Ù‡ API Keyâ€ŒÙ‡Ø§ quota ØªÙ…Ø§Ù… Ø´Ø¯Ù‡ Ø¯Ø§Ø±Ù†Ø¯. Ù„Ø·ÙØ§Ù‹ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ÛŒØ§ quota Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.', { 
            model, 
            prompt: prompt.substring(0, 200),
            errorType: 'quota_exhausted',
            helpUrl: 'https://ai.google.dev/gemini-api/docs/rate-limits'
          });
          throw new Error("Ù‡Ù…Ù‡ Ú©Ù„ÛŒØ¯Ù‡Ø§ quota ØªÙ…Ø§Ù… Ø´Ø¯Ù‡ Ø¯Ø§Ø±Ù†Ø¯. Ù„Ø·ÙØ§Ù‹ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ÛŒØ§ quota Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.");
        }
        
        addLog('error', 'Ù‡Ù…Ù‡ API Keyâ€ŒÙ‡Ø§ Ø®Ø·Ø§ Ø¯Ø§Ø¯Ù†Ø¯', { model, prompt: prompt.substring(0, 200) });
        throw lastError || new Error("Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ù‡ Ú©Ù„ÛŒØ¯Ù‡Ø§");
      });
    }
    
    // Typewriter Effect
    async function typeWriter(el, text, speed = 20) {
      el.textContent = "";
      for (let i = 0; i < text.length; i++) {
        el.textContent += text[i];
        await new Promise(r => setTimeout(r, text[i] === " " ? speed/2 : speed));
      }
    }
    
    // Parse basic Markdown-like formatting (bold and italic).
    // Bold: **text**, italic/emphasis: *text* or __text__
    function parseFormatting(text) {
      /**
       * Very small Markdown-like parser to support bold, italic and links.
       * It handles the following patterns:
       *  - Bold: **text** or __text__
       *  - Italic: *text* or _text_
       *  - Bold+italic: ***text*** or ___text___
       *  - Links: [title](url)
       *  - Inline code: `code`
       */
      if (!text) return "";
      let result = text;
      // Escape HTML special characters to prevent injection
      result = result
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      // Bold + italic (triple asterisks)
      result = result.replace(/\*\*\*([^\*]+)\*\*\*/g, '<strong><em>$1</em></strong>');
      result = result.replace(/___([^_]+)___/g, '<strong><em>$1</em></strong>');
      // Bold (double asterisks or underscores)
      result = result.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
      result = result.replace(/__([^_]+)__/g, '<strong>$1</strong>');
      // Italic (single asterisk or underscore)
      result = result.replace(/\*([^\*]+)\*/g, '<em>$1</em>');
      result = result.replace(/_([^_]+)_/g, '<em>$1</em>');
      // Links [text](url)
      result = result.replace(/\[([^\]]+)\]\(([^)]+)\)/g, function(match, title, url) {
        // Ensure url is safe (no javascript: etc.)
        const trimmed = url.trim();
        if (/^javascript:/i.test(trimmed)) {
          return title; // Strip dangerous links
        }
        return `<a href="${trimmed}" target="_blank" rel="noopener noreferrer">${title}</a>`;
      });
      // Inline code `code`
      result = result.replace(/`([^`]+)`/g, '<code>$1</code>');
      return result;
    }
    
    // Create Step Item
    function createStepItem(index, title, status = "pending") {
      const li = document.createElement("li");
      li.className = "step-item";
      li.dataset.index = index;
      li.dataset.status = status;
      const n = document.createElement("div"); n.className = "step-number"; n.textContent = index + 1;
      const label = document.createElement("div"); 
      label.className = "step-label";
      label.style.flex = "1"; 
      label.textContent = title;
      const dot = document.createElement("div"); dot.className = "step-dot";
      li.append(n, label, dot);
      return li;
    }
    
    // Create Operation Card
    function createOpCard(step, index) {
      const card = document.createElement("div"); card.className = "op-card";
      const head = document.createElement("div"); head.className = "op-head";
      const title = document.createElement("div"); title.className = "op-title";
      const num = document.createElement("div"); num.className = "op-num"; num.textContent = index + 1;
      const name = document.createElement("span"); name.textContent = step.title;
      title.append(num, name);
      const status = document.createElement("div"); status.className = "op-status"; status.textContent = "Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§...";
      head.append(title, status);
      
      const body = document.createElement("div"); body.className = "op-body";
      const thinking = document.createElement("div"); thinking.className = "thinking";
      const thLabel = document.createElement("div"); thLabel.className = "thinking-label";
      const arrow = document.createElement("button"); arrow.type = "button"; arrow.className = "arrow"; arrow.textContent = "â–¾";
      const thTitle = document.createElement("span");
      thLabel.append(arrow, thTitle);
      const thText = document.createElement("div"); thText.className = "thinking-text";
      thinking.append(thLabel, thText);
      
      const resultLabel = document.createElement("div"); resultLabel.className = "result-label";
      // Use the provided resultLabel if available; otherwise fall back to the step title
      const labelText = step.resultLabel || step.title;
      resultLabel.innerHTML = `<strong>${labelText}</strong>`;
      const result = document.createElement("div"); result.className = "result-content";
      
      body.append(thinking, resultLabel, result);
      card.append(head, body);
      
      arrow.addEventListener("click", () => {
        thinking.classList.toggle("collapsed");
        arrow.textContent = thinking.classList.contains("collapsed") ? "â–¸" : "â–¾";
      });
      
      return { card, statusEl: status, thinkingTitleEl: thTitle, thinkingTextEl: thText, resultEl: result };
    }
    
    // Render Value Chain Diagram
    function renderValueChain(container, data) {
      const diagram = document.createElement("div");
      diagram.className = "chain-diagram";
      
      (data.steps || []).forEach((step, i) => {
        const node = document.createElement("div");
        node.className = "chain-node";
        
        const circle = document.createElement("div");
        circle.className = "chain-circle";
        circle.textContent = i + 1;
        
        const label = document.createElement("div");
        label.className = "chain-label";
        label.textContent = step.provider + " â†’ " + step.receiver;
        
        const bubble = document.createElement("div");
        bubble.className = "chain-bubble";
        bubble.innerHTML = `<strong>${step.step || "Ú¯Ø§Ù… " + (i + 1)}</strong><br><br>${parseFormatting(step.description || "")}`;
        
        circle.addEventListener("click", (e) => {
          e.stopPropagation();
          document.querySelectorAll(".chain-bubble").forEach(b => b.classList.remove("active"));
          bubble.classList.add("active");
        });
        
        node.append(circle, label, bubble);
        diagram.appendChild(node);
        
        if (i < (data.steps || []).length - 1) {
          const connector = document.createElement("div");
          connector.className = "chain-connector";
          diagram.appendChild(connector);
        }
      });
      
      document.addEventListener("click", () => {
        document.querySelectorAll(".chain-bubble").forEach(b => b.classList.remove("active"));
      });
      
      container.appendChild(diagram);
    }
    
    // Parse JSON
    function parseJSON(text) {
      const a = text.indexOf("{"), b = text.lastIndexOf("}");
      if (a === -1 || b === -1) return null;
      try { return JSON.parse(text.slice(a, b + 1)); } catch { return null; }
    }
    
    // Render Canvas
    function renderCanvas(container, text) {
      const ul = document.createElement("ul"); ul.className = "canvas";
      text.split("\n").filter(l => l.trim().startsWith("-")).forEach(line => {
        const t = line.replace(/^-/, "").trim();
        const [k, ...r] = t.split(":");
        if (k && r.length) {
          const li = document.createElement("li");
          li.innerHTML = `<span class="key">${k.trim()}:</span> ${parseFormatting(r.join(":").trim())}`;
          ul.appendChild(li);
        }
      });
      container.appendChild(ul);
    }
    
    // Render Infographic
    function renderInfographic(container, data) {
      const grid = document.createElement("div"); grid.className = "infographic";
      (data.sections || []).forEach(s => {
        const card = document.createElement("div"); card.className = "ig-card";
        const t = document.createElement("div"); t.className = "ig-title"; t.textContent = s.title || "";
        const cap = document.createElement("div"); cap.className = "ig-cap"; cap.textContent = s.caption || "";
        const ul = document.createElement("ul");
        (s.bullets || []).forEach(b => { const li = document.createElement("li"); li.innerHTML = parseFormatting(b); ul.appendChild(li); });
        card.append(t, cap, ul); grid.appendChild(card);
      });
      container.appendChild(grid);
    }
    
    // Render Checklist
    function renderChecklist(container, data) {
      const list = document.createElement("div"); list.className = "checklist";
      (data.tasks || []).forEach(task => {
        const card = document.createElement("div"); card.className = "task-card";
        const header = document.createElement("div"); header.className = "task-header";
        
        const cb = document.createElement("input"); cb.type = "checkbox"; cb.className = "task-checkbox"; cb.checked = !!task.done;
        const title = document.createElement("div"); title.className = "task-title" + (task.done ? " completed" : "");
        title.innerHTML = parseFormatting(task.label || "");
        
        const meta = document.createElement("span"); meta.className = "task-meta";
        meta.textContent = [task.category, task.suggestedDay ? `Ø±ÙˆØ² ${task.suggestedDay}` : ""].filter(Boolean).join(" â€¢ ");
        
        const actions = document.createElement("div"); actions.className = "task-actions";
        const detailBtn = document.createElement("button"); detailBtn.className = "task-btn"; detailBtn.textContent = "Ø¬Ø²Ø¦ÛŒØ§Øª";
        const chatBtn = document.createElement("button"); chatBtn.className = "task-btn"; chatBtn.textContent = "ğŸ’¬ Ú†Øª";
        actions.append(detailBtn, chatBtn);
        
        header.append(cb, title, meta, actions);
        
        const details = document.createElement("div"); details.className = "task-details";
        details.textContent = "Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¬Ø²Ø¦ÛŒØ§Øª...";
        
        cb.addEventListener("change", () => {
          task.done = cb.checked;
          title.classList.toggle("completed", task.done);
        });
        
        detailBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          details.classList.toggle("open");
          if (details.classList.contains("open") && details.textContent === "Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¬Ø²Ø¦ÛŒØ§Øª...") {
            try {
              const detailText = await callGemini(config.modelThinking, `Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† ØªØ³Ú©: "${task.label}" - ÛŒÚ© Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø¹Ù…Ù„ÛŒ Ùˆ Ø®Ù„Ø§Ù‚Ø§Ù†Ù‡ Û³-Ûµ Ø¬Ù…Ù„Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ­Ù‚Ù‚ Ø¢Ù† Ø¨Ù†ÙˆÛŒØ³.`);
              details.innerHTML = parseFormatting(detailText);
            } catch (e) {
              details.textContent = "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¬Ø²Ø¦ÛŒØ§Øª.";
            }
          }
        });
        
        chatBtn.addEventListener("click", () => {
          alert(`Ú†Øª Ø¨Ø±Ø§ÛŒ ØªØ³Ú©: ${task.label}\n(Ù‚Ø§Ø¨Ù„ÛŒØª Ú†Øª Ø¯Ø± Ù†Ø³Ø®Ù‡ Ø¨Ø¹Ø¯ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯)`);
        });
        
        card.append(header, details);
        list.appendChild(card);
      });
      container.appendChild(list);
    }
    
    // Main Pipeline
    async function runPipeline() {
      const idea = userIdea.value.trim();
      if (!idea) return;
      
      addLog('info', 'Ø´Ø±ÙˆØ¹ Pipeline', { idea: idea.substring(0, 100) + (idea.length > 100 ? '...' : '') });
      
      runBtn.disabled = true;
      ops.innerHTML = "";
      if (placeholder.parentNode) placeholder.remove();
      stepsList.innerHTML = "";
      collapseInput();
      
      const loadingLi = createStepItem(-1, "Ø¯Ø± Ø­Ø§Ù„ Ø·Ø±Ø§Ø­ÛŒ Ø¹Ù…Ù„ÛŒØ§Øª...", "running");
      loadingLi.querySelector(".step-number").textContent = "â€¦";
      stepsList.appendChild(loadingLi);
      
      await new Promise(r => setTimeout(r, 400));
      stepsList.innerHTML = "";
      
      let summary = {};
      
      for (let i = 0; i < config.steps.length; i++) {
        const step = config.steps[i];
        
        addLog('info', `Ø´Ø±ÙˆØ¹ Ù…Ø±Ø­Ù„Ù‡ ${i + 1}: ${step.title}`, { stepId: step.id, stepIndex: i });
        
        // Add step to list
        const stepLi = createStepItem(i, step.title, "running");
        stepsList.appendChild(stepLi);
        
        // Scroll to active step (mobile)
        if (isMobile()) {
          stepLi.scrollIntoView({ behavior: "smooth", inline: "center", block: "nearest" });
        }
        
        // Create card
        const ui = createOpCard(step, i);
        ops.appendChild(ui.card);
        ui.card.scrollIntoView({ behavior: "smooth" });
        
        // Thinking phase
        ui.thinkingTitleEl.textContent = "";
        await typeWriter(ui.thinkingTitleEl, step.thinkingLabel, 15);
        const dots = document.createElement("span"); 
        dots.className = "dots";
        ui.thinkingTitleEl.appendChild(dots);
          
          try {
            // Step 1: Get thinking
            const thinkingPrompt = `Ø¯ØºØ¯ØºÙ‡: ${idea}\nÙ…Ø±Ø­Ù„Ù‡: ${step.title}\nØ¨Ù‡ Ø§ÛŒÙ† ÙÚ©Ø± Ú©Ù† Ùˆ ÛŒÚ© ØªØ­Ù„ÛŒÙ„ Ø¨Ù†ÙˆÛŒØ³.`;
            addLog('info', `Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªÙÚ©Ø± Ø¨Ø±Ø§ÛŒ Ù…Ø±Ø­Ù„Ù‡ ${step.title}`, { 
              stepId: step.id, 
              model: config.modelThinking,
              prompt: thinkingPrompt.substring(0, 300) + '...'
            });
            
            const thinkingText = await callGemini(config.modelThinking, thinkingPrompt);
            
            addLog('info', `ØªÙÚ©Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯ Ø¨Ø±Ø§ÛŒ ${step.title}`, { 
              stepId: step.id,
              thinkingLength: thinkingText.length,
              thinking: thinkingText.substring(0, 500) + (thinkingText.length > 500 ? '...' : '')
            });
            
            await typeWriter(ui.thinkingTextEl, thinkingText, 10);
            // Remove the dots animation element
            dots.remove();
          
          // Step 2: Get output based on thinking
          let outputPrompt = "";
          if (step.id === "value_chain") {
            outputPrompt = `Ø¨Ø± Ø§Ø³Ø§Ø³ ØªÙÚ©Ø± Ø²ÛŒØ±ØŒ Ø²Ù†Ø¬ÛŒØ±Ù‡ Ø§Ø±Ø²Ø´ Ø±Ø§ Ø¨Ù‡ ÙØ±Ù…Øª JSON Ø®Ø±ÙˆØ¬ÛŒ Ø¨Ø¯Ù‡:\n${thinkingText}\n\nÙØ±Ù…Øª:\n{"steps": [{"step": "Ú¯Ø§Ù… Û±", "provider": "Ø§Ø±Ø§Ø¦Ù‡â€ŒÚ©Ù†Ù†Ø¯Ù‡", "receiver": "Ø¯Ø±ÛŒØ§ÙØªâ€ŒÚ©Ù†Ù†Ø¯Ù‡", "description": "ØªÙˆØ¶ÛŒØ­"}]}`;
          } else if (step.id === "checklist") {
            outputPrompt = `Ø¨Ø± Ø§Ø³Ø§Ø³ ØªÙÚ©Ø± Ø²ÛŒØ±ØŒ Ú†Ú©â€ŒÙ„ÛŒØ³Øª Û±Û° Ù…ÙˆØ±Ø¯ÛŒ JSON Ø¨Ø¯Ù‡:\n${thinkingText}\n\nÙØ±Ù…Øª:\n{"tasks": [{"id": 1, "label": "...", "category": "Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ", "suggestedDay": 1, "done": false}]}`;
          } else if (step.id === "infographic") {
            outputPrompt = `Ø¨Ø± Ø§Ø³Ø§Ø³ ØªÙÚ©Ø± Ø²ÛŒØ±ØŒ Ø§ÛŒÙ†ÙÙˆÚ¯Ø±Ø§ÙÛŒÚ© JSON Ø¨Ø¯Ù‡:\n${thinkingText}\n\nÙØ±Ù…Øª:\n{"sections": [{"title": "...", "caption": "...", "bullets": ["..."]}]}`;
          } else if (step.id === "canvas") {
            outputPrompt = `Ø¨Ø± Ø§Ø³Ø§Ø³ ØªÙÚ©Ø± Ø²ÛŒØ±ØŒ Ø¨ÙˆÙ… ØªØ¹Ø§ÙˆÙ† Ø¢ÙØ±ÛŒÙ†ÛŒ Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ù„ÛŒØ³Øª Ø¨ÙˆÙ„Øª Ø¨Ù†ÙˆÛŒØ³:\n${thinkingText}\n\nÙØ±Ù…Øª:\n- Ù…Ø³Ø¦Ù„Ù‡: ...\n- Ø§Ø±Ø²Ø´ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ: ...`;
          } else {
            outputPrompt = `Ø¨Ø± Ø§Ø³Ø§Ø³ ØªÙÚ©Ø± Ø²ÛŒØ±ØŒ Ø®Ø±ÙˆØ¬ÛŒ Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³:\n${thinkingText}`;
          }
          
          addLog('info', `Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø®Ø±ÙˆØ¬ÛŒ Ø¨Ø±Ø§ÛŒ ${step.title}`, { 
            stepId: step.id,
            model: config.modelOutput,
            promptType: step.id
          });
          
          const outputText = await callGemini(config.modelOutput, outputPrompt);
          summary[step.id] = { thinking: thinkingText, output: outputText };
          
          addLog('info', `Ø®Ø±ÙˆØ¬ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯ Ø¨Ø±Ø§ÛŒ ${step.title}`, { 
            stepId: step.id,
            outputLength: outputText.length,
            output: outputText.substring(0, 500) + (outputText.length > 500 ? '...' : '')
          });
          
          // Render output
          if (step.id === "value_chain") {
            const json = parseJSON(outputText);
            if (json) {
              renderValueChain(ui.resultEl, json);
              addLog('info', `Ù†Ù…ÙˆØ¯Ø§Ø± Ø²Ù†Ø¬ÛŒØ±Ù‡ Ø§Ø±Ø²Ø´ Ø±Ù†Ø¯Ø± Ø´Ø¯`, { stepId: step.id, stepsCount: json.steps?.length || 0 });
            } else {
              ui.resultEl.innerHTML = parseFormatting(outputText);
            }
          } else if (step.id === "checklist") {
            const json = parseJSON(outputText);
            if (json) {
              renderChecklist(ui.resultEl, json);
              addLog('info', `Ú†Ú©â€ŒÙ„ÛŒØ³Øª Ø±Ù†Ø¯Ø± Ø´Ø¯`, { stepId: step.id, tasksCount: json.tasks?.length || 0 });
            } else {
              ui.resultEl.innerHTML = parseFormatting(outputText);
            }
          } else if (step.id === "infographic") {
            const json = parseJSON(outputText);
            if (json) {
              renderInfographic(ui.resultEl, json);
              addLog('info', `Ø§ÛŒÙ†ÙÙˆÚ¯Ø±Ø§ÙÛŒÚ© Ø±Ù†Ø¯Ø± Ø´Ø¯`, { stepId: step.id, sectionsCount: json.sections?.length || 0 });
            } else {
              ui.resultEl.innerHTML = parseFormatting(outputText);
            }
          } else if (step.id === "canvas") {
            renderCanvas(ui.resultEl, outputText);
            addLog('info', `Ø¨ÙˆÙ… ØªØ¹Ø§ÙˆÙ† Ø¢ÙØ±ÛŒÙ†ÛŒ Ø±Ù†Ø¯Ø± Ø´Ø¯`, { stepId: step.id });
          } else {
            ui.resultEl.innerHTML = parseFormatting(outputText);
          }
          
          ui.statusEl.textContent = "Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯";
          stepLi.dataset.status = "done";
          
          addLog('info', `Ù…Ø±Ø­Ù„Ù‡ ${step.title} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯`, { stepId: step.id, stepIndex: i });
        } catch (e) {
          ui.statusEl.textContent = "Ø®Ø·Ø§";
          stepLi.dataset.status = "error";
          
          addLog('error', `Ø®Ø·Ø§ Ø¯Ø± Ù…Ø±Ø­Ù„Ù‡ ${step.title}`, { 
            stepId: step.id,
            stepIndex: i,
            error: e.message,
            stack: e.stack
          }, e);
          
          const err = document.createElement("div");
          err.className = "error";
          err.textContent = `Ø®Ø·Ø§: ${e.message}`;
          // Retry button: restart the pipeline from the beginning so the user can try again
          const retry = document.createElement("button");
          retry.className = "retry-btn";
          retry.textContent = "â†» Ø³Ø¹ÛŒ Ù…Ø¬Ø¯Ø¯";
          retry.onclick = () => {
            runBtn.disabled = false;
            // Clear existing UI elements and start over
            ops.innerHTML = "";
            stepsList.innerHTML = "";
            // Run the pipeline again with the current idea
            runPipeline();
          };
          err.appendChild(retry);
          ui.resultEl.appendChild(err);
          break;
        }
      }
      
      addLog('info', 'Pipeline Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯', { 
        completedSteps: Object.keys(summary).length,
        totalSteps: config.steps.length
      });
      
      runBtn.disabled = false;
    }
    
    runBtn.addEventListener("click", runPipeline);
    userIdea.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); runPipeline(); }
    });
  </script>
</body>
</html>
